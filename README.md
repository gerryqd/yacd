# yacd - Yet Another CompileDB

[![CI](https://github.com/gerrywa/yacd/workflows/CI/badge.svg)](https://github.com/gerrywa/yacd/actions)
[![Go Report Card](https://goreportcard.com/badge/github.com/gerrywa/yacd)](https://goreportcard.com/report/github.com/gerrywa/yacd)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

yacd (Yet Another CompileDB) is a command-line tool for generating `compile_commands.json` files from make logs of makefile-based projects. This tool is specifically designed for C/C++ projects and is particularly useful for embedded development and cross-compilation environments.

## About the Name

Although it's called yacd, it's not yacc's younger brother! :)

## Developed with Qoder

This tool was heavily implemented with the participation of Qoder (https://qoder.com/).

## Features

- üöÄ **Efficient Parsing**: Fast parsing of logs generated by `make -Bnkw`
- üéØ **Precise Recognition**: Smart identification of compilation commands, supporting multiple compilers (GCC, Clang, ARM toolchains, etc.)
- üìÅ **Path Handling**: Support for both absolute and relative paths, with automatic working directory tracking
- üîß **Flexible Input**: Multiple input methods - file input, direct make command execution, and standard input pipes
- üîÑ **Real-time Processing**: Execute make commands directly and process output without intermediate files
- ‚úÖ **Standards Compliant**: Generates JSON files compliant with [Language Server Protocol](https://clang.llvm.org/docs/JSONCompilationDatabase.html) standards
- üß™ **High Quality**: Comprehensive unit test coverage ensuring code quality

## Installation

### Build from Source

Ensure you have Go 1.23 or higher installed.

```bash
git clone https://github.com/gerrywa/yacd.git
cd yacd
go build -o yacd .
```

### Using Go Install

```bash
go install github.com/gerrywa/yacd@latest
```

### Using Makefile

```bash
make build
```

## Usage

### Basic Usage

yacd supports three input methods:

#### Method 1: File Input

1. First, generate a make log:

```bash
make -Bnkw > build.log 2>&1
```

2. Use yacd to generate compile_commands.json:

```bash
yacd -i build.log -o compile_commands.json
```

#### Method 2: Direct Make Command Integration

```bash
# Execute make command directly and process output
yacd -n "make clean all" -o compile_commands.json
yacd --dry-run "make" --verbose
```

#### Method 3: Standard Input (Pipe)

```bash
# Read from stdin using pipe
make -Bnkw | yacd -o compile_commands.json
yacd < build.log -o compile_commands.json
```

### Command Line Options

```
yacd [flags]

Flags:
  -i, --input string      Input make log file path
  -n, --dry-run string    Execute make command with -Bnkw flags and process output directly
  -o, --output string     Output compile_commands.json file path (default "compile_commands.json")
  -r, --relative          Use relative paths instead of absolute paths
  -b, --base-dir string   Base directory path (used with --relative)
  -v, --verbose           Verbose output
  -h, --help              Show help information
```

### Examples

#### File Input Method

```bash
# Generate make log and process with yacd
make -Bnkw > build.log 2>&1
yacd -i build.log -o compile_commands.json -v
```

#### Direct Make Integration

```bash
# Execute make command directly
yacd -n "make clean all" -o compile_commands.json --verbose
yacd --dry-run "make" -o compile_commands.json
```

#### Pipe Input Method

```bash
# Use pipe to process make output directly
make -Bnkw | yacd -o compile_commands.json --verbose
echo "sample make output" | yacd -o compile_commands.json
```

#### Using Relative Paths

```bash
yacd -i build.log -o compile_commands.json --relative --base-dir /project/root
```

#### Embedded Projects

```bash
# For ARM projects using direct integration
yacd -n "make CROSS_COMPILE=arm-none-eabi-" -o compile_commands.json --verbose
```

## Supported Compilers

yacd supports automatic recognition of compilers using a simplified pattern matching approach. It can identify any compiler command containing the following patterns:

- `gcc` (includes cross-compilers like `arm-none-eabi-gcc`, `aarch64-linux-gnu-gcc`)
- `g++` (includes cross-compilers like `arm-none-eabi-g++`)
- `clang`
- `clang++`
- `cc`

This simplified approach is more universal and automatically supports various cross-compilation toolchains without requiring specific prefix definitions.

## Output Format

The generated `compile_commands.json` file complies with the Clang compilation database standard:

```json
[
  {
    "directory": "/home/user/project",
    "command": "arm-none-eabi-gcc -c -mcpu=cortex-m0 -mthumb -DNDEBUG main.c -o main.o",
    "file": "/home/user/project/main.c",
    "output": "/home/user/project/main.o"
  }
]
```

## Development

### Project Structure

```
yacd/
‚îú‚îÄ‚îÄ cmd/                # Command-line interface
‚îú‚îÄ‚îÄ generator/          # JSON generator
‚îú‚îÄ‚îÄ parser/             # Log parser
‚îú‚îÄ‚îÄ types/              # Type definitions
‚îú‚îÄ‚îÄ utils/              # Utility functions
‚îÇ   ‚îú‚îÄ‚îÄ errorutil/      # Error handling utilities
‚îÇ   ‚îî‚îÄ‚îÄ pathutil/       # Path handling utilities
‚îú‚îÄ‚îÄ scripts/            # Helper scripts
‚îú‚îÄ‚îÄ .github/workflows/  # CI/CD configuration
‚îú‚îÄ‚îÄ Makefile           # Build configuration
‚îú‚îÄ‚îÄ go.mod             # Go module definition
‚îú‚îÄ‚îÄ go.sum             # Go module checksums
‚îú‚îÄ‚îÄ main.go            # Application entry point
‚îú‚îÄ‚îÄ README.md          # Project documentation
‚îî‚îÄ‚îÄ LICENSE            # License file
```

### Build and Test

```bash
# Format code
make fmt

# Static analysis
make vet

# Run tests
make test

# Generate test coverage report
make test-coverage

# Build binary
make build

# Show sample usage examples
make run

# Show all available commands
make help
```

### Code Quality Checks

Run comprehensive code quality checks:

```bash
./scripts/quality-check.sh
```

This script performs the following checks:
- Code formatting verification
- Static analysis
- Compilation checks
- Unit tests
- Test coverage
- Module dependency verification
- Race condition detection

## Integration with Other Tools

### VSCode and clangd

The generated `compile_commands.json` can be directly used with VSCode's C/C++ extension and clangd:

1. Place the generated file in the project root directory
2. VSCode will automatically recognize it and provide intelligent code completion, navigation, and other features

### CMake Projects

While CMake can natively generate compilation databases, yacd is still useful for hybrid build systems:

```bash
# For CMake projects using make backend
cmake --build . -- -Bnkw > build.log 2>&1
yacd -i build.log -o compile_commands.json
```

## FAQ

### Q: Why parse make logs instead of modifying Makefiles?

A: Parsing logs requires no modification to existing build systems, making it minimally invasive and particularly suitable for third-party projects or complex build environments that cannot be modified.

### Q: Does it support Windows platforms?

A: Yes, yacd is cross-platform and can run on Windows, Linux, and macOS. It supports three input methods: file input (-i), direct make command execution (-n), and standard input pipes.

### Q: How does it handle complex Makefile include relationships?

A: yacd correctly handles working directory changes by tracking make's "Entering directory" and "Leaving directory" messages.

### Q: Why do generated files contain absolute paths?

A: Absolute paths are used by default to ensure compatibility. Use the `--relative` option if you need relative paths.

### Q: Can I use yacd without generating intermediate log files?

A: Yes! Use the `-n/--dry-run` option to execute make commands directly, or use pipes to process make output in real-time: `make -Bnkw | yacd -o compile_commands.json`.

## Performance

yacd has been optimized for performance:

- High memory efficiency, suitable for processing build logs from large projects
- Fast parsing speed, typically processing thousands of log lines per second
- Streaming processing support with stable memory usage

## Contributing

We welcome contributions of all kinds!

1. Fork the project
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Create a Pull Request

### Contribution Guidelines

- Ensure code passes all tests
- Add appropriate tests for new features
- Follow Go coding standards
- Update relevant documentation

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Thanks to [spf13/cobra](https://github.com/spf13/cobra) for the excellent command-line framework
- Inspired by the design concepts from the [bear](https://github.com/rizsotto/Bear) project
- Thanks to [compiledb-go](https://github.com/fcying/compiledb-go/) for reference and inspiration
- Thanks to all contributors and users for their support


---

If you find this project useful, please give us a ‚≠ê star!

For any questions or suggestions, feel free to [submit an issue](https://github.com/gerrywa/yacd/issues).